# Code Conventions

## Naming Conventions

-   Naming should be precise and semantic.

    ```
    WRONG
      let s = d/t;

    CORRECT
      let speed = distance / time;
    ```

## Variables

-   Variable name should be in camel case.
    ```
    let playerScore = 0;
    let speed = distance / time;
    ```
-   Variables should only be declared with `let` and `const` keyword.
    ```
    let playerScore = 0;
    let speed = distance / time;
    ```
-   Variables should be declared at the top of the context.

    ```
    WRONG
      let playerScore = 0;
      let speed = distance / time;

      function doSomething(
        /* Do some stuff. */
        const someVariable = 10 // wrong
      ){}

      let isFinal = false // wrong

    CORRECT
      let playerScore = 0;
      let speed = distance / time;
      let isFinal = false

      function doSomething(
        const someVariable = 10
        /* Do some stuff. */
      ){}
    ```

-   Boolean variables should start with one of these prefixes `has` ,'is', 'are'.

    ```
    let playerScore = 0;
    let speed = distance / time;
    ```

## Functions

-   Function name should be in camel case.
    ```
    function sayHello() {}
    ```
-   Event handler functions should start with word `handle`. And end with the `Event Type`.

    ```
    CORRECT
    WRONG
      function loginButtonAction() {}

    function handleLoginButtonClick() {}
    ```

-   Network handler functions should reflect it's operation.

    ```
    function getReport() {}
    function updateReport() {}
    function deleteReport() {}
    function createReport() {}
    ```

-   Functions should be `pure`.

    ```
      WRONG
      let a = 5;
      function sum(b) return a + b;
    CORRECT
      function sum(a, b) return a + b;
    ```

    For more information [Visit This Blog.](https://medium.com/javascript-scene/master-the-javascript-interview-what-is-a-pure-function-d1c076bec976)

-   Function should not be declared within if, while and etc. For more information [Visit](https://eslint.org/docs/rules/no-loop-func)

    ```
    CORRECT
      function sayHello()
      if(condition){
        sayHello()
      }

    WRONG
      if (condition) {
        function sayHello() {}
      }
    ```

-   Do not create unnamed callback/eventHandler arrow functions.

    ```
    WRONG
      <Component onClick = {()=>{ /* do some stuffs*/}}

    CORRECT
      const handleClick = (args) => { /*Do some stuff*/ }
      <Component onClick = {handleClick} />
    ```

    ```
    WRONG
      item.addEventHandler('click',(args)=>{/*Do some stuff*/ })

    CORRECT
      const handleItemClick = (args) => { /*Do some stuff*/ }
      item.addEventHandler('click', handleItemClick)
    ```

-   Infer function usage context in the name of function.
    -   Reducer functions should end with "Reducer" suffix.
    -   Data converter functions should end with "Converter" suffix.

## Components

-   Each component should have a separate folder for it in `components` folder.
-   Each component should be separated into it's container and presentational component.

-   Component name should be in `Pascal Case`.
    ```
    const ComponentName = () => {}
    ```

## Files & Folders

-   Files and Folders name should be in kebab case (camelCase).

-   Each Page should only be responsible
    -   Loading initial data.
    -   Routing.
    -   Parsing and injecting query and path parameters.
    -   Authorization & Authentication.

## Constants

-   Constant Values should be all capital and snake case.

    ```
    WRONG
      const anyConstant = value

    CORRECT
      const ANY_CONSTANT = value
    ```

## Conditions

-   Always use `===` instead of `==`, use and `!==` instead of `!=`

    ```
    WRONG
      if(a == 1){}
      if(a != 1){}

    CORRECT
      if(a === 1){}
      if(a !== 1){}
    ```

-   If the condition is complex, calculate condition before check it.
-   Name calculated condition with semantic expression.

    ```
    WRONG
      if((a === 1 || b === 5 || !c)  &&  d > 10){}

    CORRECT
      const isConditionName = (a === 1 || b === 5 || !c)  &&  d>10
      if(isConditionName){}
    ```

## Typing

-   Avoid using `any` as much as possible.
-   All interface declarations should start with `I`.
-   All type declarations should start with `T`

    ```
      Wrong
        ComponentProps

      CORRECT
        IComponentProps
    ```

    ```
    Wrong
      SomeType

    CORRECT
      TSomeType
    ```

-   All function parameters should have type.




You are an expert senior developer specializing in modern web development, with deep expertise in TypeScript, React 19, Next.js 15 (App Router), Vercel AI SDK, Shadcn UI, Radix UI, and Tailwind CSS. You are thoughtful, precise, and focus on delivering high-quality, maintainable solutions.

Analysis Process
Before responding to any request, follow these steps:

Request Analysis

Determine task type (code creation, debugging, architecture, etc.)

Identify languages and frameworks involved

Note explicit and implicit requirements

Define core problem and desired outcome

Consider project context and constraints

Solution Planning

Break down the solution into logical steps

Consider modularity and reusability

Identify necessary files and dependencies

Evaluate alternative approaches

Plan for testing and validation

Implementation Strategy

Choose appropriate design patterns

Consider performance implications

Plan for error handling and edge cases

Ensure accessibility compliance

Verify best practices alignment

Code Style and Structure
General Principles
Write concise, readable TypeScript code

Use functional and declarative programming patterns

Follow DRY (Don't Repeat Yourself) principle

Implement early returns for better readability

Structure components logically: exports, subcomponents, helpers, types

Naming Conventions
Use descriptive names with auxiliary verbs (isLoading, hasError)

Prefix event handlers with "handle" (handleClick, handleSubmit)

Use lowercase with dashes for directories (components/auth-wizard)

Favor named exports for components

TypeScript Usage
Use TypeScript for all code

Prefer interfaces over types

Avoid enums; use const maps instead

Implement proper type safety and inference

Use satisfies operator for type validation

React 19 and Next.js 15 Best Practices
Component Architecture
Favor React Server Components (RSC) where possible

Minimize 'use client' directives

Implement proper error boundaries

Use Suspense for async operations

Optimize for performance and Web Vitals

State Management
Use useActionState instead of deprecated useFormState

Leverage enhanced useFormStatus with new properties (data, method, action)

Implement URL state management with 'nuqs'

Minimize client-side state

Async Request APIs
// Always use async versions of runtime APIs
const cookieStore = await cookies()
const headersList = await headers()
const { isEnabled } = await draftMode()

// Handle async params in layouts/pages
const params = await props.params
const searchParams = await props.searchParams
Data Fetching
Fetch requests are no longer cached by default

Use cache: 'force-cache' for specific cached requests

Implement fetchCache = 'default-cache' for layout/page-level caching

Use appropriate fetching methods (Server Components, SWR, React Query)

Route Handlers
// Cached route handler example
export const dynamic = 'force-static'

export async function GET(request: Request) {
const params = await request.params
// Implementation
}
Vercel AI SDK Integration
Core Concepts
Use the AI SDK for building AI-powered streaming text and chat UIs

Leverage three main packages:

ai - Core functionality and streaming utilities

@ai-sdk/[provider] - Model provider integrations (e.g., OpenAI)

React hooks for UI components

Route Handler Setup
import { openai } from '@ai-sdk/openai';
import { streamText } from 'ai';

export const maxDuration = 30;

export async function POST(req: Request) {
const { messages } = await req.json();

const result = await streamText({
model: openai('gpt-4-turbo'),
messages,
tools: {
// Tool definitions
},
});

return result.toDataStreamResponse();
}
Chat UI Implementation
'use client';

import { useChat } from 'ai/react';

export default function Chat() {
const { messages, input, handleInputChange, handleSubmit } = useChat({
maxSteps: 5, // Enable multi-step interactions
});

return (

<div className="flex flex-col w-full max-w-md py-24 mx-auto stretch">
{messages.map(m => (
<div key={m.id} className="whitespace-pre-wrap">
{m.role === 'user' ? 'User: ' : 'AI: '}
{m.toolInvocations ? (
<pre>{JSON.stringify(m.toolInvocations, null, 2)}</pre>
) : (
m.content
)}
</div>
))}

      <form onSubmit={handleSubmit}>
        <input
          className="fixed bottom-0 w-full max-w-md p-2 mb-8 border border-gray-300 rounded shadow-xl"
          value={input}
          placeholder="Say something..."
          onChange={handleInputChange}
        />
      </form>
    </div>

);
}
UI Development
Styling
Use Tailwind CSS with a mobile-first approach

Implement Shadcn UI and Radix UI components

Follow consistent spacing and layout patterns

Ensure responsive design across breakpoints

Use CSS variables for theme customization

Accessibility
Implement proper ARIA attributes

Ensure keyboard navigation

Provide appropriate alt text

Follow WCAG 2.1 guidelines

Test with screen readers

Performance
Optimize images (WebP, sizing, lazy loading)

Implement code splitting

Use next/font for font optimization

Configure staleTimes for client-side router cache

Monitor Core Web Vitals

Configuration
Next.js Config
/\*_ @type {import('next').NextConfig} _/
const nextConfig = {
// Stable features (formerly experimental)
bundlePagesRouterDependencies: true,
serverExternalPackages: ['package-name'],

// Router cache configuration
experimental: {
staleTimes: {
dynamic: 30,
static: 180,
},
},
}
TypeScript Config
{
"compilerOptions": {
"strict": true,
"target": "ES2022",
"lib": ["dom", "dom.iterable", "esnext"],
"jsx": "preserve",
"module": "esnext",
"moduleResolution": "bundler",
"noEmit": true,
"paths": {
"@/_": ["./src/_"]
}
}
}
Testing and Validation
Code Quality
Implement comprehensive error handling

Write maintainable, self-documenting code

Follow security best practices

Ensure proper type coverage

Use ESLint and Prettier

Testing Strategy
Plan for unit and integration tests

Implement proper test coverage

Consider edge cases and error scenarios

Validate accessibility compliance

Use React Testing Library

Remember: Prioritize clarity and maintainability while delivering robust, accessible, and performant solutions aligned with the latest React 19, Next.js 15, and Vercel AI SDK features and best practices

// declarations.d.ts & css-modules.d.ts
- Strong typing enforcement
- Module declarations
- CSS modules typing
// app/data.tsx
- Centralized data structures
- Type-safe data management
- Separation of concerns

Typing Standards:
Strict TypeScript usage
Interface/Type definitions
Module declaration
Component Standards:
Context-based state management
Reusable components
Type-safe props

Component Standards:
Context-based state management
Reusable components
Type-safe props


// SidebarContext.tsx
- React Context API usage
- Proper type definitions
- Component-based state management

// app/data.tsx
- Centralized data structures
- Type-safe data management
- Separation of concerns


Typescript coding style guide
Naming
The name of a variable, function, or class, should answer all the big questions. It should tell you why it exists, what it does, and how it is used. If a name requires a comment, then the name does not reveal its intent.

Use meaningful variable names.

Distinguish names in such a way that the reader knows what the differences offer.

Bad:

function isBetween(a1: number, a2: number, a3: number): boolean {
  return a2 <= a1 && a1 <= a3;
}
Good:

 function isBetween(value: number, left: number, right: number): boolean {
   return left <= value && value <= right;
 }
Use pronounceable variable names

If you can't pronounce it, you can't discuss it without sounding weird.

Bad:

class Subs {
  public ccId: number;
  public billingAddrId: number;
  public shippingAddrId: number;
}
Good:

class Subscription {
  public creditCardId: number;
  public billingAddressId: number;
  public shippingAddressId: number;
}
Avoid mental mapping

Explicit is better than implicit.
Clarity is king.

Bad:

const u = getUser();
const s = getSubscription();
const t = charge(u, s);
Good:

const user = getUser();
const subscription = getSubscription();
const transaction = charge(user, subscription);
Don't add unneeded context

If your class/type/object name tells you something, don't repeat that in your variable name.

Bad:

type Car = {
  carMake: string;
  carModel: string;
  carColor: string;
}

function print(car: Car): void {
  console.log(`${car.carMake} ${car.carModel} (${car.carColor})`);
}
Good:

type Car = {
  make: string;
  model: string;
  color: string;
}

function print(car: Car): void {
  console.log(`${car.make} ${car.model} (${car.color})`);
}
Naming Conventions
Use camelCase for variable and function names
Bad:

var FooVar;
function BarFunc() { }
Good:

var fooVar;
function barFunc() { }
Use camelCase of class members, interface members, methods and methods parameters
Bad:

class Foo {
  Bar: number;
  Baz() { }
}
Good:

class Foo {
  bar: number;
  baz() { }
}
Use PascalCase for class names and interface names.
Bad:

class foo { }
Good:

class Foo { }
Use PascalCase for enums and camelCase for enum members
Bad:

enum notificationTypes {
  Default = 0,
  Info = 1,
  Success = 2,
  Error = 3,
  Warning = 4
}
Good:

enum NotificationTypes {
  default = 0,
  info = 1,
  success = 2,
  error = 3,
  warning = 4
}
Naming Booleans
Don't use negative names for boolean variables.
Bad:

const isNotEnabled = true;
Good:

const isEnabled = false;
A prefix like is, are, or has helps every developer to distinguish a boolean from another variable by just looking at it
Bad:

const enabled = false;
Good:

const isEnabled = false;
Brackets
OTBS (one true brace style). Wikipedia
The one true brace style is one of the most common brace styles in TypeScript, in which the opening brace of a block is placed on the same line as its corresponding statement or declaration.

if (foo) {
  bar();
}
else {
  baz();
}
Do not omit curly brackets

Always wrap the body of the statement in curly brackets.

Spaces
Use 2 spaces. Not tabs.

Semicolons
Use semicolons.

Code Comments
So when you find yourself in a position where you need to write a comment, think it through and see whether there isn't some way to turn the tables and express yourself in code. Every time you express yourself in code, you should pat yourself on the back. Everytime you write a comment, you should grimace and feel the failure of your ability of expression.

Bad Comments

Most comments fall into this category. Usually they are crutches or excuses for poor code or justifications for insufficient decisions, amounting to little more than the programmer talking to himself.

Mumbling

Plopping in a comment just because you feel you should or because the process requires it, is a hack. If you decide to write a comment, then spend the time necessary to make sure it is the best comment you can write.

Noise Comments

Sometimes you see comments that are nothing but noise. They restate the obvious and provide no new information.

// redirect to the Contact Details screen
this.router.navigateByUrl(`/${ROOT}/contact`);
// self explanatory, parse ...
this.parseProducts(products);
Scary noise

/** The name. */
private name;

/** The version. */
private version;

/** The licenceName. */
private licenceName;

/** The version. */
private info;
Read these comments again more carefully. Do you see the cut-paste error? If authors aren't paying attention when comments are written (or pasted), why should readers be expected to profit from them?

TODO Comments

In general, TODO comments are a big risk. We may see something that we want to do later so we drop a quick // TODO: Replace this method thinking we'll come back to it but never do.

If you're going to write a TODO comment, you should link to your external issue tracker.

There are valid use cases for a TODO comment. Perhaps you're working on a big feature and you want to make a pull request that only fixes part of it. You also want to call out some refactoring that still needs to be done, but that you'll fix in another PR.

// TODO: Consolidate both of these classes. PURCHASE-123
This is actionable because it forces us to go to our issue tracker and create a ticket. That is less likely to get lost than a code comment that will potentially never be seen again.

Comments can sometimes be useful

When explaining why something is being implemented in a particular way.
When explaining complex algorithms (when all other methods for simplifying the algorithm have been tried and come up short).
Comment conventions

Write comments in English.

Do not add empty comments

Begin single-line comments with a single space

Good:

// Single-line comment
Bad:

//Single-line comment
//  Single-line comment
Write single-line comments properly

Single-line comments should always be preceded by a single blank line.
Single-line comments should never be followed by blank line(s).
Good:

const x;

// This comment is valid
const y;
Bad:

const x;

// This comment is not valid

const y;
const x;
// This comment is not valid

const y;
Do not write embedded comments

Do not write comments between declaration of statement and opening curly brackets.
Place comments above statements, or within statement body.
Good:

// This method does something..
public method() {
}
Bad:

public method() { // This method does something..
}
public method() {
// This method does something..
}
Barrels
A barrel is a way to rollup exports from several modules into a single convenience module. The barrel itself is a module file that re-exports selected exports of other modules.

import noise - this is an issue seen in languages where there are dependencies that need to be "imported", "required", or "included" and the first (1 - n) lines are non functional code.

Example of a barrel file:

export * from './product-added-dialog.component';
export * from './website-selector.component';
export * from './product-family-selector.component';
export * from './individual-product-selector.component';
export * from './license-type-selector.component';
export * from './period-and-quantity-selector.component';
How to use it inside components:

Good:

import { CartsService, PaidSupportService, SettingsService } from '@modules/services';
Bad:

import { SettingsService } from './settings/settings.service';
import { CartsService } from './carts/carts.service';
import { PaidSupportService } from './paid-support/paid-support.service';
Barrel files are named index.ts by convention
Do not import a barrel in the files that are already used in that barrel because this leads to circular dependency

Place documentation prior to decoratorscopy link to the clipboard
When a class, method, or property have both decorators like @Component and JsDoc, please make sure to write the JsDoc before the decorator.

Do not write JsDoc between the Decorator and the decorated statement.

isibilitycopy link to the clipboard
Restricting visibility of properties, methods, and entire types helps with keeping code decoupled.

Limit symbol visibility as much as possible.
Consider converting private methods to non-exported functions within the same file but outside of any class, and moving private properties into a separate, non-exported class.
TypeScript symbols are public by default. Never use the public modifier except when declaring non-readonly public parameter properties (in constructors).
class Foo {
  public bar = new Bar(); // BAD: public modifier not needed

  constructor(public readonly baz: Baz) {} // BAD: readonly implies it's a property which defaults to public
}
class Foo {
  bar = new Bar(); // GOOD: public modifier not needed

  constructor(public baz: Baz) {} // public modifier allowed
}

